#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
xtf-qmtest-runner Utility for running XTF test using the QMTest framework.
"""

########################################################################
# Imports
########################################################################

import gc
import os
import os.path
import sys
import traceback
import qm
if sys.platform != "win32":
    import qm.sigmask

import qm.test.base
import qm.test.cmdline
from   qm.test.database import set_path
from   qm.test.result import Result

class XTFQMTest(qm.test.cmdline.QMTest):
    """XTF QMTest instalce"""

    tag_option_spec = (
        "F",
        "filter",
        "ARGUMENT=VALUE",
        "Run only the tests for which the argument matches the VALUE tag.",
    )

    def __init__(self, argument_list, path):
        insert_option = lambda x,y: x[:4] + (x[4] + (y, ), ) + x[5:]
        qm.test.cmdline.QMTest.commands_spec[:] = [
            insert_option(x, self.tag_option_spec) if x[0] == "run" else x
            for x in qm.test.cmdline.QMTest.commands_spec]
        qm.test.cmdline.QMTest.__init__(self, argument_list, path)

    def Execute(self):
        return qm.test.cmdline.QMTest.Execute(self)

    def _QMTest__FilterTestsToRun(self, test_ids, expectations):
        """Return those tests from 'test_ids' that should be run.

        'test_ids' -- A sequence of test ids.

        'expectations' -- An ExpectationDatabase.

        returns -- Those elements of 'test_names' that are not to be
        skipped.  If 'a' precedes 'b' in 'test_ids', and both 'a' and
        'b' are present in the result, 'a' will precede 'b' in the
        result."""

        # The --rerun option indicates that only failing tests should
        # be rerun.
        rerun_file_name = self.GetCommandOption("rerun")
        if rerun_file_name:
            # Load the outcomes from the file specified.
            outcomes = qm.test.base.load_outcomes(rerun_file_name,
                                          self.GetDatabase())
            # Filter out tests that have unexpected outcomes.
            test_ids = [t for t in test_ids
                        if outcomes.get(t, Result.PASS)
                        != expectations.Lookup(t).GetOutcome()]

        #print qm.test.cmdline.QMTest.commands_spec

        return test_ids


########################################################################
# Functions
########################################################################

def print_error_message(message):
    """Output an error message.

    'message' -- Structured text for the error message to emit.  The
    messing is emitted to the standard error stream with an
    identifying prefix."""

    prefix = "qmtest: error: "
    message = qm.structured_text.to_text(str(message),
                                         indent=len(prefix))
    message = prefix + message[len(prefix):]
    sys.stderr.write(message)

def main():
    """ xtf-qmtest-runner entry point. """

    # Normalise $CWD to the directory this script is in
    os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))

    if sys.platform != "win32":
        qm.sigmask.save_mask()

    # Parse the command line.
    command = XTFQMTest(sys.argv[1:], sys.argv[0])

    # Execute the command.
    return command.Execute()

if __name__ == "__main__":
    # Assume that something will go wrong.
    exit_code = 2

    try:
        # Set database path
        set_path(os.path.join(os.getcwd(), "qmtest"))

        # Set the program name.
        qm.common.program_name = "XTFQMTest"

        # Load messages.
        qm.diagnostic.load_messages("test")

        # Load RC options.
        qm.rc.Load("test")

        try:
            exit_code = main()
        except qm.cmdline.CommandError, msg:
            print_error_message(msg)
            sys.stderr.write(
                "Run 'xtf-qmtest-runner --help'\n")
        except qm.common.QMException, msg:
            print_error_message(msg)
        except NotImplementedError:
            exc_info = sys.exc_info()
            method_name = traceback.extract_tb(exc_info[2])[-1][2]
            print_error_message(qm.message("not implemented",
                                        method_name = method_name))
            sys.stderr.write(qm.common.format_traceback(exc_info))
        except KeyboardInterrupt:
            sys.stderr.write("\nqmtest: Interrupted.\n")
            raise
        except qm.platform.SignalException, se:
            # SIGTERM indicates a request to shut down.  Other signals
            # should be handled earlier.
            #if se.GetSignalNumber() != signal.SIGTERM:
            raise
    finally:
        # Collect garbage so that any "__del__" methods with externally
        # visible side-effects are executed.
        del qm.test.cmdline._the_qmtest
        gc.collect()

    # End the program.
    sys.exit(exit_code)

